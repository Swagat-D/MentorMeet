// backend/src/services/googleCalendar.service.ts - Enhanced Google Calendar Integration
import { google } from 'googleapis';
import { OAuth2Client } from 'google-auth-library';
import User from '../models/User.model';
import { Session } from '../models/Session.model';

interface CalendarEvent {
  summary: string;
  description: string;
  startTime: string;
  endTime: string;
  attendees: Array<{
    email: string;
    name?: string;
  }>;
  meetingLink?: string;
  timezone?: string;
}

interface MeetingCreationResult {
  success: boolean;
  meetingLink?: string;
  calendarEventId?: string;
  error?: string;
}

class GoogleCalendarService {
  private oauth2Client: OAuth2Client;
  private calendar: any;

  constructor() {
    this.oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET,
      process.env.GOOGLE_REDIRECT_URI
    );

    this.calendar = google.calendar({ version: 'v3', auth: this.oauth2Client });
  }

  /**
   * Initialize OAuth2 client with service account for app-level access
   */
  private async initializeServiceAuth(): Promise<boolean> {
    try {
      if (!process.env.GOOGLE_SERVICE_ACCOUNT_KEY) {
        console.error('‚ùå Google Service Account key not found');
        return false;
      }

      const serviceAccountKey = JSON.parse(process.env.GOOGLE_SERVICE_ACCOUNT_KEY);
      
      const jwtClient = new google.auth.JWT({
        email: serviceAccountKey.client_email,
        key: serviceAccountKey.private_key,
        scopes: [
          'https://www.googleapis.com/auth/calendar',
          'https://www.googleapis.com/auth/calendar.events'
        ]
      });

      await jwtClient.authorize();
      this.calendar = google.calendar({ version: 'v3', auth: jwtClient });
      
      console.log('‚úÖ Google Service Account initialized');
      return true;
    } catch (error) {
      console.error('‚ùå Service account initialization failed:', error);
      return false;
    }
  }

  /**
   * Create a mentoring session with Google Meet integration
   */
  async createMentoringSession(sessionData: {
    mentorEmail: string;
    studentEmail: string;
    mentorName: string;
    studentName: string;
    subject: string;
    startTime: string;
    endTime: string;
    sessionId: string;
    timezone?: string;
  }): Promise<MeetingCreationResult> {
    try {
      console.log('üé• Creating mentoring session with Google Meet...');
      
      // Initialize service auth
      const authSuccess = await this.initializeServiceAuth();
      if (!authSuccess) {
        throw new Error('Failed to authenticate with Google Calendar');
      }

      const {
        mentorEmail,
        studentEmail,
        mentorName,
        studentName,
        subject,
        startTime,
        endTime,
        sessionId,
        timezone = 'UTC'
      } = sessionData;

      // Create calendar event with Google Meet
      const eventData = {
        summary: `Mentoring Session: ${subject}`,
        description: `
üéì Mentoring Session Details

üìö Subject: ${subject}
üë®‚Äçüè´ Mentor: ${mentorName} (${mentorEmail})
üë®‚Äçüéì Student: ${studentName} (${studentEmail})

üìã Session ID: ${sessionId}
üïí Duration: ${this.calculateDuration(startTime, endTime)} minutes

üìù Instructions:
‚Ä¢ Join the meeting using the Google Meet link below
‚Ä¢ Please join 2-3 minutes before the scheduled time
‚Ä¢ Ensure you have a stable internet connection
‚Ä¢ Have your questions and materials ready

üìû Technical Support: If you experience any issues, please contact our support team.

---
Generated by MentorMatch Platform
        `.trim(),
        start: {
          dateTime: startTime,
          timeZone: timezone,
        },
        end: {
          dateTime: endTime,
          timeZone: timezone,
        },
        attendees: [
          {
            email: mentorEmail,
            displayName: mentorName,
            responseStatus: 'accepted'
          },
          {
            email: studentEmail,
            displayName: studentName,
            responseStatus: 'needsAction'
          }
        ],
        conferenceData: {
          createRequest: {
            requestId: `mentoring-${sessionId}-${Date.now()}`,
            conferenceSolutionKey: {
              type: 'hangoutsMeet',
            },
          },
        },
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'email', minutes: 60 },
            { method: 'email', minutes: 15 },
            { method: 'popup', minutes: 10 },
          ],
        },
        guestsCanModify: false,
        guestsCanInviteOthers: false,
        guestsCanSeeOtherGuests: true,
        visibility: 'private',
        status: 'confirmed',
      };

      console.log('üìÖ Creating calendar event...');
      
      const response = await this.calendar.events.insert({
        calendarId: 'primary',
        conferenceDataVersion: 1,
        sendUpdates: 'all', // Send email invitations to all attendees
        requestBody: eventData,
      });

      const createdEvent = response.data;
      console.log('‚úÖ Calendar event created:', createdEvent.id);

      // Extract Google Meet link
      let meetingLink = '';
      if (createdEvent.conferenceData?.entryPoints) {
        const meetEntry = createdEvent.conferenceData.entryPoints.find(
          (entry: any) => entry.entryPointType === 'video'
        );
        meetingLink = meetEntry?.uri || '';
      }

      // Fallback to hangoutLink
      if (!meetingLink && createdEvent.hangoutLink) {
        meetingLink = createdEvent.hangoutLink;
      }

      if (!meetingLink) {
        console.warn('‚ö†Ô∏è No Google Meet link generated, creating fallback');
        meetingLink = `https://meet.google.com/${this.generateMeetingCode()}`;
      }

      console.log('üîó Meeting link generated:', meetingLink);

      // Update the session in database with meeting details
      await this.updateSessionWithMeetingDetails(sessionId, {
        meetingLink,
        calendarEventId: createdEvent.id!,
        meetingProvider: 'google_meet'
      });

      return {
        success: true,
        meetingLink,
        calendarEventId: createdEvent.id!,
      };

    } catch (error: any) {
      console.error('‚ùå Error creating mentoring session:', error);
      
      // Create fallback meeting link
      const fallbackLink = `https://meet.google.com/${this.generateMeetingCode()}`;
      
      try {
        await this.updateSessionWithMeetingDetails(sessionData.sessionId, {
          meetingLink: fallbackLink,
          calendarEventId: `fallback-${Date.now()}`,
          meetingProvider: 'fallback'
        });
      } catch (dbError) {
        console.error('‚ùå Failed to update session with fallback:', dbError);
      }

      return {
        success: false,
        meetingLink: fallbackLink,
        error: error.message,
      };
    }
  }

  /**
   * Update session in database with meeting details
   */
  private async updateSessionWithMeetingDetails(
    sessionId: string,
    meetingDetails: {
      meetingLink: string;
      calendarEventId: string;
      meetingProvider: string;
    }
  ): Promise<void> {
    try {
      await Session.findByIdAndUpdate(sessionId, {
        meetingLink: meetingDetails.meetingLink,
        calendarEventId: meetingDetails.calendarEventId,
        meetingProvider: meetingDetails.meetingProvider,
        updatedAt: new Date(),
      });
      
      console.log('‚úÖ Session updated with meeting details');
    } catch (error) {
      console.error('‚ùå Failed to update session:', error);
      throw error;
    }
  }

  /**
   * Cancel/delete a calendar event
   */
  async cancelMentoringSession(calendarEventId: string): Promise<boolean> {
    try {
      console.log('üóëÔ∏è Cancelling calendar event:', calendarEventId);
      
      const authSuccess = await this.initializeServiceAuth();
      if (!authSuccess) {
        console.warn('‚ö†Ô∏è Failed to authenticate, skipping calendar deletion');
        return false;
      }

      await this.calendar.events.delete({
        calendarId: 'primary',
        eventId: calendarEventId,
        sendUpdates: 'all', // Notify all attendees
      });

      console.log('‚úÖ Calendar event cancelled successfully');
      return true;
    } catch (error: any) {
      console.error('‚ùå Error cancelling calendar event:', error);
      return false;
    }
  }

  /**
   * Reschedule a calendar event
   */
  async rescheduleMentoringSession(
    calendarEventId: string,
    newStartTime: string,
    newEndTime: string,
    timezone: string = 'UTC'
  ): Promise<boolean> {
    try {
      console.log('üìù Rescheduling calendar event:', calendarEventId);
      
      const authSuccess = await this.initializeServiceAuth();
      if (!authSuccess) {
        console.warn('‚ö†Ô∏è Failed to authenticate, skipping calendar update');
        return false;
      }

      const updateData = {
        start: {
          dateTime: newStartTime,
          timeZone: timezone,
        },
        end: {
          dateTime: newEndTime,
          timeZone: timezone,
        },
      };

      await this.calendar.events.patch({
        calendarId: 'primary',
        eventId: calendarEventId,
        sendUpdates: 'all',
        requestBody: updateData,
      });

      console.log('‚úÖ Calendar event rescheduled successfully');
      return true;
    } catch (error: any) {
      console.error('‚ùå Error rescheduling calendar event:', error);
      return false;
    }
  }

  /**
   * Generate a random meeting code for fallback
   */
  private generateMeetingCode(): string {
    const chars = 'abcdefghijklmnopqrstuvwxyz';
    let code = '';
    for (let i = 0; i < 12; i++) {
      if (i === 3 || i === 7) {
        code += '-';
      } else {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
      }
    }
    return code;
  }

  /**
   * Calculate duration between two times
   */
  private calculateDuration(startTime: string, endTime: string): number {
    const start = new Date(startTime);
    const end = new Date(endTime);
    return Math.round((end.getTime() - start.getTime()) / (1000 * 60));
  }

  /**
   * Check if Google Calendar API is available
   */
  async isServiceAvailable(): Promise<boolean> {
    try {
      const authSuccess = await this.initializeServiceAuth();
      if (!authSuccess) return false;

      // Test API access
      await this.calendar.calendarList.list();
      return true;
    } catch (error) {
      console.error('‚ùå Google Calendar service unavailable:', error);
      return false;
    }
  }

  /**
   * Get event details by ID
   */
  async getEventDetails(calendarEventId: string): Promise<any> {
    try {
      const authSuccess = await this.initializeServiceAuth();
      if (!authSuccess) {
        throw new Error('Authentication failed');
      }

      const response = await this.calendar.events.get({
        calendarId: 'primary',
        eventId: calendarEventId,
      });

      return response.data;
    } catch (error: any) {
      console.error('‚ùå Error getting event details:', error);
      throw error;
    }
  }
}

export default new GoogleCalendarService();